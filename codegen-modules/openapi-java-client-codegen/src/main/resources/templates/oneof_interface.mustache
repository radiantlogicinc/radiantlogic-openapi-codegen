{{#isInvalidUnionType}}
/**
 * This interface was defined by a discriminated union schema in an OpenAPI specification, however the
 * specification lacked the mapping for the discriminator. The result is that this interface on its own
 * cannot be serialized or de-serialized due to that missing type information.
 *
 * To compensate for this flaw, additional logic has been added to this interface. Please do the following
 * when trying to serialize and/or de-serialize it:
 *
 * FOR SERIALIZATION = First call to{{classname}}Raw() on the instance you are trying to serialize. Then
 *                     serialize what is returned from that method.
 *
 * FOR DESERIALIZATION = Use the type {{classname}}.Raw rather than this type directly when de-serializing.
 *                       That will at least give you a custom Map of all properties. If you know the specific
 *                       implementation type, you can also call toImplementation(ClassName.class) on the Raw
 *                       type to convert it.
 */
{{/isInvalidUnionType}}
{{#discriminator}}
{{#hasDiscriminatorWithNonEmptyMapping}}
{{>additionalOneOfTypeAnnotations}}{{>generatedAnnotation}}{{>typeInfoAnnotation}}{{>xmlAnnotation}}
{{/hasDiscriminatorWithNonEmptyMapping}}
{{/discriminator}}
public interface {{classname}} {{#vendorExtensions.x-implements}}{{#-first}}extends {{{.}}}{{/-first}}{{^-first}}, {{{.}}}{{/-first}}{{/vendorExtensions.x-implements}} {
    {{#discriminator}}
    {{propertyType}} {{propertyGetter}}();
    {{/discriminator}}

    {{#isInvalidUnionType}}
    /**
     * Convert the instance of this interface into the Raw type. The Raw type will be modified during the conversion
     * so that issues due to the missing discriminator mapping are resolved. When attempting to serialize implementations
     * of this interface
     *
     * This method contains the classname in it because multiple interfaces like this may be implemented by a single class
     * thus the need to avoid naming collisions. The Raw type produced by any toClassnameRaw() method on an implementation of
     * this interface will always be serializable to the same output.
     */
    default Raw to{{classname}}Raw() {
        final Raw raw = JacksonConfig.OBJECT_MAPPER.convertValue(this, Raw.class);
        {{#discriminator}}
        final Object discriminatorValue = JacksonConfig.OBJECT_MAPPER.convertValue({{propertyGetter}}(), Object.class);
        // The lack of a property discriminator mapping screws up the discriminator value during serialization, this fixes it
        raw.put("{{propertyName}}", discriminatorValue);
        {{/discriminator}}
        return raw;
    }

    /**
     * This represents the raw JSON data associated with this type. It allows for safely de-serializing JSON
     * despite not having proper openapi discriminator mapping information.
     */
    class Raw extends HashMap<String, Object> {
        {{#discriminator}}
        public {{propertyType}} {{propertyGetter}}() {
            {{#isEnum}}
                return {{propertyType}}.fromValue((String) get("{{propertyName}}"));
            {{/isEnum}}
            {{#useConstructor}}
                return {{propertyType}}(String.valueOf(get("{{propertyName}}")));
            {{/useConstructor}}
            {{#useCast}}
                return ({{propertyType}}) get("{{propertyName}}");
            {{/useCast}}
        }
        {{/discriminator}}

        public <T extends {{classname}}> T toImplementation(final Class<T> type) {
            return JacksonConfig.OBJECT_MAPPER.convertValue(this, type);
        }
    }
    {{/isInvalidUnionType}}

{{#vars}}
    {{#isEnum}}
        {{^isContainer}}
{{>modelInnerEnum}}
        {{/isContainer}}
        {{#isContainer}}
            {{#mostInnerItems}}
{{>modelInnerEnum}}
            {{/mostInnerItems}}
        {{/isContainer}}
    {{/isEnum}}
{{/vars}}
}
